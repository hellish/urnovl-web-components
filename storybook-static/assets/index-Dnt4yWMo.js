var S={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!0,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1},we="app",Re=Object.defineProperty,Oe=(e,t)=>{for(var s in t)Re(e,s,{get:t[s],enumerable:!0})},ce=new WeakMap,R=e=>ce.get(e),Pe=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$onReadyPromise$=new Promise(r=>s.$onReadyResolve$=r),e["s-p"]=[],e["s-rc"]=[],ce.set(e,s)},J=(e,t)=>t in e,P=(e,t)=>(0,console.error)(e,t),j=new Map,Fe=[],Ue="slot-fb{display:contents}slot-fb[hidden]{display:none}",Y="http://www.w3.org/1999/xlink",F=typeof window<"u"?window:{},m=F.document||{head:{}},xt=F.HTMLElement||class{},h={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,r)=>e.addEventListener(t,s,r),rel:(e,t,s,r)=>e.removeEventListener(t,s,r),ce:(e,t)=>new CustomEvent(e,t)},je=(()=>{let e=!1;try{m.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),Ne=e=>Promise.resolve(e),fe=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),M=!1,Z=[],de=[],De=(e,t)=>s=>{e.push(s),M||(M=!0,t&&h.$flags$&4?q(B):h.raf(B))},V=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){P(s)}e.length=0},B=()=>{V(Z),V(de),(M=Z.length>0)&&h.raf(B)},q=e=>Ne().then(e),He=De(de,!0),ee={},Ce="http://www.w3.org/2000/svg",Me="http://www.w3.org/1999/xhtml",Be=e=>e!=null,I=e=>(e=typeof e,e==="object"||e==="function");function We(e){var t,s,r;return(r=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?r:void 0}var ze={};Oe(ze,{err:()=>ue,map:()=>qe,ok:()=>W,unwrap:()=>Ie,unwrapErr:()=>Qe});var W=e=>({isOk:!0,isErr:!1,value:e}),ue=e=>({isOk:!1,isErr:!0,value:e});function qe(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(r=>W(r)):W(s)}if(e.isErr){const s=e.value;return ue(s)}throw"should never get here"}var Ie=e=>{if(e.isOk)return e.value;throw e.value},Qe=e=>{if(e.isErr)return e.value;throw e.value},L=(e,t="")=>()=>{},pe=(e,t,...s)=>{let r=null,n=null,l=null,i=!1,a=!1;const o=[],$=c=>{for(let u=0;u<c.length;u++)r=c[u],Array.isArray(r)?$(r):r!=null&&typeof r!="boolean"&&((i=typeof e!="function"&&!I(r))&&(r=String(r)),i&&a?o[o.length-1].$text$+=r:o.push(i?N(null,r):r),a=i)};if($(s),t){t.key&&(n=t.key),t.name&&(l=t.name);{const c=t.className||t.class;c&&(t.class=typeof c!="object"?c:Object.keys(c).filter(u=>c[u]).join(" "))}}if(typeof e=="function")return e(t===null?{}:t,o,Ke);const d=N(e,null);return d.$attrs$=t,o.length>0&&(d.$children$=o),d.$key$=n,d.$name$=l,d},N=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s.$key$=null,s.$name$=null,s},Xe={},Ge=e=>e&&e.$tag$===Xe,Ke={forEach:(e,t)=>e.map(te).forEach(t),map:(e,t)=>e.map(te).map(t).map(Je)},te=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Je=e=>{if(typeof e.vtag=="function"){const s={...e.vattrs};return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),pe(e.vtag,s,...e.vchildren||[])}const t=N(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Ye=e=>Fe.map(t=>t(e)).find(t=>!!t),Ze=(e,t)=>e!=null&&!I(e)?t&4?e==="false"?!1:e===""||!!e:t&2?parseFloat(e):t&1?String(e):e:e,Ve=e=>e,Lt=(e,t,s)=>{const r=Ve(e);return{emit:n=>ve(r,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:n})}},ve=(e,t,s)=>{const r=h.ce(t,s);return e.dispatchEvent(r),r},se=new WeakMap,et=(e,t,s)=>{let r=j.get(e);fe&&s?(r=r||new CSSStyleSheet,typeof r=="string"?r=t:r.replaceSync(t)):r=t,j.set(e,r)},tt=(e,t,s)=>{var r;const n=he(t,s),l=j.get(n);if(e=e.nodeType===11?e:m,l)if(typeof l=="string"){e=e.head||e;let i=se.get(e),a;if(i||se.set(e,i=new Set),!i.has(n)){{a=m.createElement("style"),a.innerHTML=l;const o=(r=h.$nonce$)!=null?r:We(m);if(o!=null&&a.setAttribute("nonce",o),!(t.$flags$&1))if(e.nodeName==="HEAD"){const $=e.querySelectorAll("link[rel=preconnect]"),d=$.length>0?$[$.length-1].nextSibling:e.querySelector("style");e.insertBefore(a,d)}else if("host"in e)if(fe){const $=new CSSStyleSheet;$.replaceSync(l),e.adoptedStyleSheets=[$,...e.adoptedStyleSheets]}else{const $=e.querySelector("style");$?$.innerHTML=l+$.innerHTML:e.prepend(a)}else e.append(a);t.$flags$&1&&e.nodeName!=="HEAD"&&e.insertBefore(a,null)}t.$flags$&4&&(a.innerHTML+=Ue),i&&i.add(n)}}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return n},st=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,r=t.$flags$,n=L("attachStyles",t.$tagName$),l=tt(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);r&10&&r&2&&(s["s-sc"]=l,s.classList.add(l+"-h"),r&2&&s.classList.add(l+"-s")),n()},he=(e,t)=>"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),re=(e,t,s,r,n,l)=>{if(s!==r){let i=J(e,t),a=t.toLowerCase();if(t==="class"){const o=e.classList,$=ne(s),d=ne(r);o.remove(...$.filter(c=>c&&!d.includes(c))),o.add(...d.filter(c=>c&&!$.includes(c)))}else if(t==="style"){for(const o in s)(!r||r[o]==null)&&(o.includes("-")?e.style.removeProperty(o):e.style[o]="");for(const o in r)(!s||r[o]!==s[o])&&(o.includes("-")?e.style.setProperty(o,r[o]):e.style[o]=r[o])}else if(t!=="key")if(t==="ref")r&&r(e);else if(!e.__lookupSetter__(t)&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):J(F,a)?t=a.slice(2):t=a[2]+t.slice(3),s||r){const o=t.endsWith(ge);t=t.replace(nt,""),s&&h.rel(e,t,s,o),r&&h.ael(e,t,r,o)}}else{const o=I(r);if((i||o&&r!==null)&&!n)try{if(e.tagName.includes("-"))e[t]=r;else{const d=r??"";t==="list"?i=!1:(s==null||e[t]!=d)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=d:e.setAttribute(t,d))}}catch{}let $=!1;a!==(a=a.replace(/^xlink\:?/,""))&&(t=a,$=!0),r==null||r===!1?(r!==!1||e.getAttribute(t)==="")&&($?e.removeAttributeNS(Y,t):e.removeAttribute(t)):(!i||l&4||n)&&!o&&(r=r===!0?"":r,$?e.setAttributeNS(Y,t,r):e.setAttribute(t,r))}}},rt=/\s/,ne=e=>e?e.split(rt):[],ge="Capture",nt=new RegExp(ge+"$"),ye=(e,t,s)=>{const r=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,n=e&&e.$attrs$||ee,l=t.$attrs$||ee;for(const i of le(Object.keys(n)))i in l||re(r,i,n[i],void 0,s,t.$flags$);for(const i of le(Object.keys(l)))re(r,i,n[i],l[i],s,t.$flags$)};function le(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var E,z,w,D=!1,H=!1,Q=!1,y=!1,C=(e,t,s,r)=>{var n;const l=t.$children$[s];let i=0,a,o,$;if(D||(Q=!0,l.$tag$==="slot"&&(E&&r.classList.add(E+"-s"),l.$flags$|=l.$children$?2:1)),l.$text$!==null)a=l.$elm$=m.createTextNode(l.$text$);else if(l.$flags$&1)a=l.$elm$=m.createTextNode("");else{if(y||(y=l.$tag$==="svg"),a=l.$elm$=m.createElementNS(y?Ce:Me,!D&&S.slotRelocation&&l.$flags$&2?"slot-fb":l.$tag$),y&&l.$tag$==="foreignObject"&&(y=!1),ye(null,l,y),!!a.getRootNode().querySelector("body")&&S.scoped&&Be(E)&&a["s-si"]!==E&&a.classList.add(a["s-si"]=E),G(a,r),l.$children$)for(i=0;i<l.$children$.length;++i)o=C(e,l,i,a),o&&a.appendChild(o);l.$tag$==="svg"?y=!1:a.tagName==="foreignObject"&&(y=!0)}return a["s-hn"]=w,l.$flags$&3&&(a["s-sr"]=!0,a["s-cr"]=z,a["s-sn"]=l.$name$||"",a["s-rf"]=(n=l.$attrs$)==null?void 0:n.ref,$=e&&e.$children$&&e.$children$[s],$&&$.$tag$===l.$tag$&&e.$elm$&&O(e.$elm$,!1)),a},O=(e,t)=>{h.$flags$|=1;const s=Array.from(e.childNodes);if(e["s-sr"]&&S.experimentalSlotFixes){let r=e;for(;r=r.nextSibling;)r&&r["s-sn"]===e["s-sn"]&&r["s-sh"]===w&&s.push(r)}for(let r=s.length-1;r>=0;r--){const n=s[r];n["s-hn"]!==w&&n["s-ol"]&&(T(ke(n),n,X(n)),n["s-ol"].remove(),n["s-ol"]=void 0,n["s-sh"]=void 0,Q=!0),t&&O(n,t)}h.$flags$&=-2},Se=(e,t,s,r,n,l)=>{let i=e["s-cr"]&&e["s-cr"].parentNode||e,a;for(i.shadowRoot&&i.tagName===w&&(i=i.shadowRoot);n<=l;++n)r[n]&&(a=C(null,s,n,e),a&&(r[n].$elm$=a,T(i,a,X(t))))},me=(e,t,s)=>{for(let r=t;r<=s;++r){const n=e[r];if(n){const l=n.$elm$;xe(n),l&&(H=!0,l["s-ol"]?l["s-ol"].remove():O(l,!0),l.remove())}}},lt=(e,t,s,r,n=!1)=>{let l=0,i=0,a=0,o=0,$=t.length-1,d=t[0],c=t[$],u=r.length-1,f=r[0],p=r[u],k,g;for(;l<=$&&i<=u;)if(d==null)d=t[++l];else if(c==null)c=t[--$];else if(f==null)f=r[++i];else if(p==null)p=r[--u];else if(U(d,f,n))_(d,f,n),d=t[++l],f=r[++i];else if(U(c,p,n))_(c,p,n),c=t[--$],p=r[--u];else if(U(d,p,n))(d.$tag$==="slot"||p.$tag$==="slot")&&O(d.$elm$.parentNode,!1),_(d,p,n),T(e,d.$elm$,c.$elm$.nextSibling),d=t[++l],p=r[--u];else if(U(c,f,n))(d.$tag$==="slot"||p.$tag$==="slot")&&O(c.$elm$.parentNode,!1),_(c,f,n),T(e,c.$elm$,d.$elm$),c=t[--$],f=r[++i];else{for(a=-1,o=l;o<=$;++o)if(t[o]&&t[o].$key$!==null&&t[o].$key$===f.$key$){a=o;break}a>=0?(g=t[a],g.$tag$!==f.$tag$?k=C(t&&t[i],s,a,e):(_(g,f,n),t[a]=void 0,k=g.$elm$),f=r[++i]):(k=C(t&&t[i],s,i,e),f=r[++i]),k&&T(ke(d.$elm$),k,X(d.$elm$))}l>$?Se(e,r[u+1]==null?null:r[u+1].$elm$,s,r,i,u):i>u&&me(t,l,$)},U=(e,t,s=!1)=>e.$tag$===t.$tag$?e.$tag$==="slot"?"$nodeId$"in e&&s&&e.$elm$.nodeType!==8?!1:e.$name$===t.$name$:s?!0:e.$key$===t.$key$:!1,X=e=>e&&e["s-ol"]||e,ke=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,_=(e,t,s=!1)=>{const r=t.$elm$=e.$elm$,n=e.$children$,l=t.$children$,i=t.$tag$,a=t.$text$;let o;a===null?(y=i==="svg"?!0:i==="foreignObject"?!1:y,i==="slot"&&!D||ye(e,t,y),n!==null&&l!==null?lt(r,n,t,l,s):l!==null?(e.$text$!==null&&(r.textContent=""),Se(r,null,t,l,0,l.length-1)):!s&&S.updatable&&n!==null&&me(n,0,n.length-1),y&&i==="svg"&&(y=!1)):(o=r["s-cr"])?o.parentNode.textContent=a:e.$text$!==a&&(r.data=a)},be=e=>{const t=e.childNodes;for(const s of t)if(s.nodeType===1){if(s["s-sr"]){const r=s["s-sn"];s.hidden=!1;for(const n of t)if(n!==s){if(n["s-hn"]!==s["s-hn"]||r!==""){if(n.nodeType===1&&(r===n.getAttribute("slot")||r===n["s-sn"])||n.nodeType===3&&r===n["s-sn"]){s.hidden=!0;break}}else if(n.nodeType===1||n.nodeType===3&&n.textContent.trim()!==""){s.hidden=!0;break}}}be(s)}},b=[],Te=e=>{let t,s,r;for(const n of e.childNodes){if(n["s-sr"]&&(t=n["s-cr"])&&t.parentNode){s=t.parentNode.childNodes;const l=n["s-sn"];for(r=s.length-1;r>=0;r--)if(t=s[r],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==n["s-hn"]&&!S.experimentalSlotFixes)if(oe(t,l)){let i=b.find(a=>a.$nodeToRelocate$===t);H=!0,t["s-sn"]=t["s-sn"]||l,i?(i.$nodeToRelocate$["s-sh"]=n["s-hn"],i.$slotRefNode$=n):(t["s-sh"]=n["s-hn"],b.push({$slotRefNode$:n,$nodeToRelocate$:t})),t["s-sr"]&&b.map(a=>{oe(a.$nodeToRelocate$,t["s-sn"])&&(i=b.find(o=>o.$nodeToRelocate$===t),i&&!a.$slotRefNode$&&(a.$slotRefNode$=i.$slotRefNode$))})}else b.some(i=>i.$nodeToRelocate$===t)||b.push({$nodeToRelocate$:t})}n.nodeType===1&&Te(n)}},oe=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",xe=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(xe)},T=(e,t,s)=>{const r=e==null?void 0:e.insertBefore(t,s);return G(t,e),r},Le=e=>{const t=[];return e&&t.push(...e["s-scs"]||[],e["s-si"],e["s-sc"],...Le(e.parentElement)),t},G=(e,t,s=!1)=>{var r;if(e&&t&&e.nodeType===1){const n=new Set(Le(t).filter(Boolean));if(n.size&&((r=e.classList)==null||r.add(...e["s-scs"]=Array.from(n)),e["s-ol"]||s))for(const l of Array.from(e.childNodes))G(l,e,!0)}},ot=(e,t,s=!1)=>{var r,n,l,i,a;const o=e.$hostElement$,$=e.$cmpMeta$,d=e.$vnode$||N(null,null),c=Ge(t)?t:pe(null,null,t);if(w=o.tagName,$.$attrsToReflect$&&(c.$attrs$=c.$attrs$||{},$.$attrsToReflect$.map(([u,f])=>c.$attrs$[f]=o[u])),s&&c.$attrs$)for(const u of Object.keys(c.$attrs$))o.hasAttribute(u)&&!["key","ref","style","class"].includes(u)&&(c.$attrs$[u]=o[u]);c.$tag$=null,c.$flags$|=4,e.$vnode$=c,c.$elm$=d.$elm$=o.shadowRoot||o,E=o["s-sc"],D=($.$flags$&1)!==0,z=o["s-cr"],H=!1,_(d,c,s);{if(h.$flags$|=1,Q){Te(c.$elm$);for(const u of b){const f=u.$nodeToRelocate$;if(!f["s-ol"]){const p=m.createTextNode("");p["s-nr"]=f,T(f.parentNode,f["s-ol"]=p,f)}}for(const u of b){const f=u.$nodeToRelocate$,p=u.$slotRefNode$;if(p){const k=p.parentNode;let g=p.nextSibling;{let x=(r=f["s-ol"])==null?void 0:r.previousSibling;for(;x;){let v=(n=x["s-nr"])!=null?n:null;if(v&&v["s-sn"]===f["s-sn"]&&k===v.parentNode){for(v=v.nextSibling;v===f||v!=null&&v["s-sr"];)v=v==null?void 0:v.nextSibling;if(!v||!v["s-nr"]){g=v;break}}x=x.previousSibling}}(!g&&k!==f.parentNode||f.nextSibling!==g)&&f!==g&&(!f["s-hn"]&&f["s-ol"]&&(f["s-hn"]=f["s-ol"].parentNode.nodeName),T(k,f,g),f.nodeType===1&&(f.hidden=(l=f["s-ih"])!=null?l:!1)),f&&typeof p["s-rf"]=="function"&&p["s-rf"](f)}else f.nodeType===1&&(s&&(f["s-ih"]=(i=f.hidden)!=null?i:!1),f.hidden=!0)}}H&&be(c.$elm$),h.$flags$&=-2,b.length=0}if(S.experimentalScopedSlotChanges&&$.$flags$&2)for(const u of c.$elm$.childNodes)u["s-hn"]!==w&&!u["s-sh"]&&(s&&u["s-ih"]==null&&(u["s-ih"]=(a=u.hidden)!=null?a:!1),u.hidden=!0);z=void 0},Ee=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},K=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return Ee(e,e.$ancestorComponent$),He(()=>at(e,t))},at=(e,t)=>{const s=e.$hostElement$,r=L("scheduleUpdate",e.$cmpMeta$.$tagName$),n=s;if(!n)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t?l=A(n,"componentWillLoad"):l=A(n,"componentWillUpdate"),l=ae(l,()=>A(n,"componentWillRender")),r(),ae(l,()=>$t(e,n,t))},ae=(e,t)=>it(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),it=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",$t=async(e,t,s)=>{var r;const n=e.$hostElement$,l=L("update",e.$cmpMeta$.$tagName$),i=n["s-rc"];s&&st(e);const a=L("render",e.$cmpMeta$.$tagName$);ct(e,t,n,s),i&&(i.map(o=>o()),n["s-rc"]=void 0),a(),l();{const o=(r=n["s-p"])!=null?r:[],$=()=>ft(e);o.length===0?$():(Promise.all(o).then($),e.$flags$|=4,o.length=0)}},ie=null,ct=(e,t,s,r)=>{try{ie=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(S.hasRenderFn||S.reflect)&&(S.vdomRender||S.reflect)&&(S.hydrateServerSide||ot(e,t,r))}catch(o){P(o,e.$hostElement$)}return ie=null,null},ft=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,r=L("postUpdate",t),n=s,l=e.$ancestorComponent$;A(n,"componentDidRender"),e.$flags$&64?(A(n,"componentDidUpdate"),r()):(e.$flags$|=64,_e(s),A(n,"componentDidLoad"),r(),e.$onReadyResolve$(s),l||dt()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&q(()=>K(e,!1)),e.$flags$&=-517},dt=e=>{_e(m.documentElement),q(()=>ve(F,"appload",{detail:{namespace:we}}))},A=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(r){P(r)}},_e=e=>{var t;return e.classList.add((t=S.hydratedSelectorName)!=null?t:"hydrated")},ut=(e,t)=>R(e).$instanceValues$.get(t),pt=(e,t,s,r)=>{const n=R(e),l=e,i=n.$instanceValues$.get(t),a=n.$flags$,o=l;s=Ze(s,r.$members$[t][0]);const $=Number.isNaN(i)&&Number.isNaN(s);if(s!==i&&!$){n.$instanceValues$.set(t,s);{if(r.$watchers$&&a&128){const c=r.$watchers$[t];c&&c.map(u=>{try{o[u](s,i,t)}catch(f){P(f,l)}})}if((a&18)===2){if(o.componentShouldUpdate&&o.componentShouldUpdate(s,i,t)===!1)return;K(n,!1)}}}},vt=(e,t,s)=>{var r,n;const l=e.prototype;if(t.$members$||t.$watchers$||e.watchers){e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);const i=Object.entries((r=t.$members$)!=null?r:{});i.map(([a,[o]])=>{(o&31||o&32)&&Object.defineProperty(l,a,{get(){return ut(this,a)},set($){pt(this,a,$,t)},configurable:!0,enumerable:!0})});{const a=new Map;l.attributeChangedCallback=function(o,$,d){h.jmp(()=>{var c;const u=a.get(o);if(this.hasOwnProperty(u))d=this[u],delete this[u];else{if(l.hasOwnProperty(u)&&typeof this[u]=="number"&&this[u]==d)return;if(u==null){const f=R(this),p=f==null?void 0:f.$flags$;if(p&&!(p&8)&&p&128&&d!==$){const g=this,x=(c=t.$watchers$)==null?void 0:c[o];x==null||x.forEach(v=>{g[v]!=null&&g[v].call(g,d,$,o)})}return}}this[u]=d===null&&typeof this[u]=="boolean"?!1:d})},e.observedAttributes=Array.from(new Set([...Object.keys((n=t.$watchers$)!=null?n:{}),...i.filter(([o,$])=>$[0]&15).map(([o,$])=>{var d;const c=$[1]||o;return a.set(c,o),$[0]&512&&((d=t.$attrsToReflect$)==null||d.push([o,c])),c})]))}}return e},ht=async(e,t,s,r)=>{let n;if(!(t.$flags$&32)){t.$flags$|=32,s.$lazyBundleId$;{n=e.constructor;const a=e.localName;customElements.whenDefined(a).then(()=>t.$flags$|=128)}if(n&&n.style){let a;typeof n.style=="string"?a=n.style:typeof n.style!="string"&&(t.$modeName$=Ye(e),t.$modeName$&&(a=n.style[t.$modeName$]));const o=he(s,t.$modeName$);if(!j.has(o)){const $=L("registerStyles",s.$tagName$);et(o,a,!!(s.$flags$&1)),$()}}}const l=t.$ancestorComponent$,i=()=>K(t,!0);l&&l["s-rc"]?l["s-rc"].push(i):i()},$e=e=>{},gt=e=>{if(!(h.$flags$&1)){const t=R(e),s=t.$cmpMeta$,r=L("connectedCallback",s.$tagName$);if(t.$flags$&1)Ae(e,t,s.$listeners$),t!=null&&t.$lazyInstance$?$e(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>$e(t.$lazyInstance$));else{t.$flags$|=1,s.$flags$&12&&yt(e);{let n=e;for(;n=n.parentNode||n.host;)if(n["s-p"]){Ee(t,t.$ancestorComponent$=n);break}}s.$members$&&Object.entries(s.$members$).map(([n,[l]])=>{if(l&31&&e.hasOwnProperty(n)){const i=e[n];delete e[n],e[n]=i}}),ht(e,t,s)}r()}},yt=e=>{const t=e["s-cr"]=m.createComment("");t["s-cn"]=!0,T(e,t,e.firstChild)},St=async e=>{if(!(h.$flags$&1)){const t=R(e);t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0)}},Et=(e,t)=>{customElements.define(t[1],mt(e,t))},mt=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};s.$members$=t[2],s.$listeners$=t[3],s.$watchers$=e.$watchers$,s.$attrsToReflect$=[];const r=e.prototype.connectedCallback,n=e.prototype.disconnectedCallback;let l=!1;return Object.assign(e.prototype,{__registerHost(){Pe(this,s)},connectedCallback(){if(!l){const i=R(this);Ae(this,i,s.$listeners$),l=!0}gt(this),r&&r.call(this)},disconnectedCallback(){St(this),n&&n.call(this)},__attachShadow(){if(!this.shadowRoot)this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)});else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}),e.is=s.$tagName$,vt(e,s)},Ae=(e,t,s,r)=>{s&&s.map(([n,l,i])=>{const a=bt(e,n),o=kt(t,i),$=Tt(n);h.ael(a,l,o,$),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>h.rel(a,l,o,$))})},kt=(e,t)=>s=>{var r;try{S.lazyLoad||e.$hostElement$[t](s)}catch(n){P(n)}},bt=(e,t)=>t&4?m:t&8?F:t&16?m.body:e,Tt=e=>je?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;export{xt as H,Xe as a,Lt as c,Et as d,pe as h};
