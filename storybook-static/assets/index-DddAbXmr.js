var S={allRenderFn:!1,element:!0,event:!0,hasRenderFn:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!0,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1},we="app",je=Object.defineProperty,He=(e,t)=>{for(var s in t)je(e,s,{get:t[s],enumerable:!0})},Pe="http://www.w3.org/2000/svg",De="http://www.w3.org/1999/xhtml",Fe=(e,t)=>{var s;const n=t.$cmpMeta$;Object.entries((s=n.$members$)!=null?s:{}).map(([l,[i]])=>{if(i&31||i&32){const o=e[l],a=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e),l);Object.defineProperty(e,l,{get(){return a.get.call(this)},set(c){a.set.call(this,c)},configurable:!0,enumerable:!0}),e[l]=t.$instanceValues$.has(l)?t.$instanceValues$.get(l):o}})},T=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},Ue=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};s.$onReadyPromise$=new Promise(r=>s.$onReadyResolve$=r),e["s-p"]=[],e["s-rc"]=[];const n=s;return e.__stencil__getHostRef=()=>n,S.modernPropertyDecls&&S.state&&Fe(e,s),n},ee=(e,t)=>t in e,H=(e,t)=>(0,console.error)(e,t),B=new Map,Ce=[],Be="sty-id",Me="slot-fb{display:contents}slot-fb[hidden]{display:none}",te="http://www.w3.org/1999/xlink",v=typeof window<"u"?window:{},Rt=v.HTMLElement||class{},g={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},ze=(()=>{var e;let t=!1;try{(e=v.document)==null||e.addEventListener("e",null,Object.defineProperty({},"passive",{get(){t=!0}}))}catch{}return t})(),Ne=e=>Promise.resolve(e),pe=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),I=!1,se=[],he=[],qe=(e,t)=>s=>{e.push(s),I||(I=!0,t&&g.$flags$&4?K(G):g.raf(G))},ne=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){H(s)}e.length=0},G=()=>{ne(se),ne(he),(I=se.length>0)&&g.raf(G)},K=e=>Ne().then(e),We=qe(he,!0),Ie=e=>e!=null&&e!==void 0,J=e=>(e=typeof e,e==="object"||e==="function");function Ge(e){var t,s,n;return(n=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?n:void 0}var Qe={};He(Qe,{err:()=>ve,map:()=>Xe,ok:()=>Q,unwrap:()=>Ye,unwrapErr:()=>Ke});var Q=e=>({isOk:!0,isErr:!1,value:e}),ve=e=>({isOk:!1,isErr:!0,value:e});function Xe(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(n=>Q(n)):Q(s)}if(e.isErr){const s=e.value;return ve(s)}throw"should never get here"}var Ye=e=>{if(e.isOk)return e.value;throw e.value},Ke=e=>{if(e.isErr)return e.value;throw e.value},ge=e=>{const t=le(e,"childNodes");e.tagName&&e.tagName.includes("-")&&e["s-cr"]&&e.tagName!=="SLOT-FB"&&ye(t,e.tagName).forEach(n=>{n.nodeType===1&&n.tagName==="SLOT-FB"&&(Ze(n,Z(n),!1).length?n.hidden=!0:n.hidden=!1)});let s=0;for(s=0;s<t.length;s++){const n=t[s];n.nodeType===1&&le(n,"childNodes").length&&ge(n)}},Je=e=>{const t=[];for(let s=0;s<e.length;s++){const n=e[s]["s-nr"]||void 0;n&&n.isConnected&&t.push(n)}return t};function ye(e,t,s){let n=0,r=[],l;for(;n<e.length;n++)l=e[n],l["s-sr"]&&(!t||l["s-hn"]===t)&&s===void 0&&r.push(l),r=[...r,...ye(l.childNodes,t,s)];return r}var Ze=(e,t,s=!0)=>{const n=[];(s&&e["s-sr"]||!e["s-sr"])&&n.push(e);let r=e;for(;r=r.nextSibling;)Z(r)===t&&(s||!r["s-sr"])&&n.push(r);return n},re=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",Z=e=>typeof e["s-sn"]=="string"?e["s-sn"]:e.nodeType===1&&e.getAttribute("slot")||void 0;function Ve(e){if(e.assignedElements||e.assignedNodes||!e["s-sr"])return;const t=s=>(function(n){const r=[],l=this["s-sn"];n!=null&&n.flatten&&console.error(`
          Flattening is not supported for Stencil non-shadow slots. 
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);const i=this["s-cr"].parentElement;return(i.__childNodes?i.childNodes:Je(i.childNodes)).forEach(a=>{l===Z(a)&&r.push(a)}),s?r.filter(a=>a.nodeType===1):r}).bind(e);e.assignedElements=t(!0),e.assignedNodes=t(!1)}function le(e,t){if("__"+t in e){const s=e["__"+t];return typeof s!="function"?s:s.bind(e)}else return typeof e[t]!="function"?e[t]:e[t].bind(e)}var x=(e,t="")=>()=>{},Se=(e,t,...s)=>{let n=null,r=null,l=null,i=!1,o=!1;const a=[],c=u=>{for(let $=0;$<u.length;$++)n=u[$],Array.isArray(n)?c(n):n!=null&&typeof n!="boolean"&&((i=typeof e!="function"&&!J(n))&&(n=String(n)),i&&o?a[a.length-1].$text$+=n:a.push(i?M(null,n):n),o=i)};if(c(s),t){t.key&&(r=t.key),t.name&&(l=t.name);{const u=t.className||t.class;u&&(t.class=typeof u!="object"?u:Object.keys(u).filter($=>u[$]).join(" "))}}if(typeof e=="function")return e(t===null?{}:t,a,st);const f=M(e,null);return f.$attrs$=t,a.length>0&&(f.$children$=a),f.$key$=r,f.$name$=l,f},M=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s.$key$=null,s.$name$=null,s},et={},tt=e=>e&&e.$tag$===et,st={forEach:(e,t)=>e.map(oe).forEach(t),map:(e,t)=>e.map(oe).map(t).map(nt)},oe=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),nt=e=>{if(typeof e.vtag=="function"){const s={...e.vattrs};return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),Se(e.vtag,s,...e.vchildren||[])}const t=M(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},rt=e=>Ce.map(t=>t(e)).find(t=>!!t),_e=(e,t)=>e!=null&&!J(e)?t&4?e==="false"?!1:e===""||!!e:t&2?typeof e=="string"?parseFloat(e):typeof e=="number"?e:NaN:t&1?String(e):e:e,lt=e=>e,wt=(e,t,s)=>{const n=lt(e);return{emit:r=>ke(n,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:r})}},ke=(e,t,s)=>{const n=g.ce(t,s);return e.dispatchEvent(n),n},O=new WeakMap,ot=(e,t,s)=>{let n=B.get(e);pe&&s?(n=n||new CSSStyleSheet,typeof n=="string"?n=t:n.replaceSync(t)):n=t,B.set(e,n)},it=(e,t,s)=>{var n;const r=be(t,s),l=B.get(r);if(!v.document)return r;if(e=e.nodeType===11?e:v.document,l)if(typeof l=="string"){e=e.head||e;let i=O.get(e),o;if(i||O.set(e,i=new Set),!i.has(r)){{o=document.querySelector(`[${Be}="${r}"]`)||v.document.createElement("style"),o.innerHTML=l;const a=(n=g.$nonce$)!=null?n:Ge(v.document);if(a!=null&&o.setAttribute("nonce",a),!(t.$flags$&1))if(e.nodeName==="HEAD"){const c=e.querySelectorAll("link[rel=preconnect]"),f=c.length>0?c[c.length-1].nextSibling:e.querySelector("style");e.insertBefore(o,(f==null?void 0:f.parentNode)===e?f:null)}else if("host"in e)if(pe){const c=new CSSStyleSheet;c.replaceSync(l),e.adoptedStyleSheets=[c,...e.adoptedStyleSheets]}else{const c=e.querySelector("style");c?c.innerHTML=l+c.innerHTML:e.prepend(o)}else e.append(o);t.$flags$&1&&e.insertBefore(o,null)}t.$flags$&4&&(o.innerHTML+=Me),i&&i.add(r)}}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return r},at=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,r=x("attachStyles",t.$tagName$),l=it(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);n&10&&(s["s-sc"]=l,s.classList.add(l+"-h")),r()},be=(e,t)=>"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),ie=(e,t,s,n,r,l,i)=>{if(s===n)return;let o=ee(e,t),a=t.toLowerCase();if(t==="class"){const c=e.classList,f=ae(s);let u=ae(n);c.remove(...f.filter($=>$&&!u.includes($))),c.add(...u.filter($=>$&&!f.includes($)))}else if(t==="style"){for(const c in s)(!n||n[c]==null)&&(c.includes("-")?e.style.removeProperty(c):e.style[c]="");for(const c in n)(!s||n[c]!==s[c])&&(c.includes("-")?e.style.setProperty(c,n[c]):e.style[c]=n[c])}else if(t!=="key")if(t==="ref")n&&n(e);else if(!e.__lookupSetter__(t)&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):ee(v,a)?t=a.slice(2):t=a[2]+t.slice(3),s||n){const c=t.endsWith(me);t=t.replace($t,""),s&&g.rel(e,t,s,c),n&&g.ael(e,t,n,c)}}else{const c=J(n);if((o||c&&n!==null)&&!r)try{if(e.tagName.includes("-"))e[t]!==n&&(e[t]=n);else{const u=n??"";t==="list"?o=!1:(s==null||e[t]!=u)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=u:e.setAttribute(t,u))}}catch{}let f=!1;a!==(a=a.replace(/^xlink\:?/,""))&&(t=a,f=!0),n==null||n===!1?(n!==!1||e.getAttribute(t)==="")&&(f?e.removeAttributeNS(te,t):e.removeAttribute(t)):(!o||l&4||r)&&!c&&e.nodeType===1&&(n=n===!0?"":n,f?e.setAttributeNS(te,t,n):e.setAttribute(t,n))}},ct=/\s/,ae=e=>(typeof e=="object"&&e&&"baseVal"in e&&(e=e.baseVal),!e||typeof e!="string"?[]:e.split(ct)),me="Capture",$t=new RegExp(me+"$"),X=(e,t,s,n)=>{const r=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||{},i=t.$attrs$||{};for(const o of ce(Object.keys(l)))o in i||ie(r,o,l[o],void 0,s,t.$flags$);for(const o of ce(Object.keys(i)))ie(r,o,l[o],i[o],s,t.$flags$)};function ce(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var C,z,R,Y=!1,N=!1,V=!1,_=!1,q=(e,t,s)=>{var n;const r=t.$children$[s];let l=0,i,o,a;if(Y||(V=!0,r.$tag$==="slot"&&(r.$flags$|=r.$children$?2:1)),r.$text$!==null)i=r.$elm$=v.document.createTextNode(r.$text$);else if(r.$flags$&1)i=r.$elm$=v.document.createTextNode(""),X(null,r,_);else{if(_||(_=r.$tag$==="svg"),!v.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(i=r.$elm$=v.document.createElementNS(_?Pe:De,!Y&&S.slotRelocation&&r.$flags$&2?"slot-fb":r.$tag$),_&&r.$tag$==="foreignObject"&&(_=!1),X(null,r,_),Ie(C)&&i["s-si"]!==C&&i.classList.add(i["s-si"]=C),r.$children$)for(l=0;l<r.$children$.length;++l)o=q(e,r,l),o&&i.appendChild(o);r.$tag$==="svg"?_=!1:i.tagName==="foreignObject"&&(_=!0)}return i["s-hn"]=R,r.$flags$&3&&(i["s-sr"]=!0,i["s-cr"]=z,i["s-sn"]=r.$name$||"",i["s-rf"]=(n=r.$attrs$)==null?void 0:n.ref,Ve(i),a=e&&e.$children$&&e.$children$[s],a&&a.$tag$===r.$tag$&&e.$elm$&&w(e.$elm$,!1),Oe(z,i,t.$elm$,e==null?void 0:e.$elm$)),i},w=(e,t)=>{g.$flags$|=1;const s=Array.from(e.__childNodes||e.childNodes);if(e["s-sr"]&&S.experimentalSlotFixes){let n=e;for(;n=n.nextSibling;)n&&n["s-sn"]===e["s-sn"]&&n["s-sh"]===R&&s.push(n)}for(let n=s.length-1;n>=0;n--){const r=s[n];r["s-hn"]!==R&&r["s-ol"]&&(E(j(r).parentNode,r,j(r)),r["s-ol"].remove(),r["s-ol"]=void 0,r["s-sh"]=void 0,V=!0),t&&w(r,t)}g.$flags$&=-2},Ee=(e,t,s,n,r,l)=>{let i=e["s-cr"]&&e["s-cr"].parentNode||e,o;for(i.shadowRoot&&i.tagName===R&&(i=i.shadowRoot);r<=l;++r)n[r]&&(o=q(null,s,r),o&&(n[r].$elm$=o,E(i,o,j(t))))},Te=(e,t,s)=>{for(let n=t;n<=s;++n){const r=e[n];if(r){const l=r.$elm$;Le(r),l&&(N=!0,l["s-ol"]?l["s-ol"].remove():w(l,!0),l.remove())}}},ft=(e,t,s,n,r=!1)=>{let l=0,i=0,o=0,a=0,c=t.length-1,f=t[0],u=t[c],$=n.length-1,p=n[0],d=n[$],h,k;for(;l<=c&&i<=$;)if(f==null)f=t[++l];else if(u==null)u=t[--c];else if(p==null)p=n[++i];else if(d==null)d=n[--$];else if(U(f,p,r))L(f,p,r),f=t[++l],p=n[++i];else if(U(u,d,r))L(u,d,r),u=t[--c],d=n[--$];else if(U(f,d,r))(f.$tag$==="slot"||d.$tag$==="slot")&&w(f.$elm$.parentNode,!1),L(f,d,r),E(e,f.$elm$,u.$elm$.nextSibling),f=t[++l],d=n[--$];else if(U(u,p,r))(f.$tag$==="slot"||d.$tag$==="slot")&&w(u.$elm$.parentNode,!1),L(u,p,r),E(e,u.$elm$,f.$elm$),u=t[--c],p=n[++i];else{for(o=-1,a=l;a<=c;++a)if(t[a]&&t[a].$key$!==null&&t[a].$key$===p.$key$){o=a;break}o>=0?(k=t[o],k.$tag$!==p.$tag$?h=q(t&&t[i],s,o):(L(k,p,r),t[o]=void 0,h=k.$elm$),p=n[++i]):(h=q(t&&t[i],s,i),p=n[++i]),h&&E(j(f.$elm$).parentNode,h,j(f.$elm$))}l>c?Ee(e,n[$+1]==null?null:n[$+1].$elm$,s,n,i,$):i>$&&Te(t,l,c)},U=(e,t,s=!1)=>e.$tag$===t.$tag$?e.$tag$==="slot"?e.$name$===t.$name$:s?(s&&!e.$key$&&t.$key$&&(e.$key$=t.$key$),!0):e.$key$===t.$key$:!1,j=e=>e&&e["s-ol"]||e,L=(e,t,s=!1)=>{const n=t.$elm$=e.$elm$,r=e.$children$,l=t.$children$,i=t.$tag$,o=t.$text$;let a;o===null?(_=i==="svg"?!0:i==="foreignObject"?!1:_,X(e,t,_),r!==null&&l!==null?ft(n,r,t,l,s):l!==null?(e.$text$!==null&&(n.textContent=""),Ee(n,null,t,l,0,l.length-1)):!s&&S.updatable&&r!==null&&Te(r,0,r.length-1),_&&i==="svg"&&(_=!1)):(a=n["s-cr"])?a.parentNode.textContent=o:e.$text$!==o&&(n.data=o)},m=[],xe=e=>{let t,s,n;const r=e.__childNodes||e.childNodes;for(const l of r){if(l["s-sr"]&&(t=l["s-cr"])&&t.parentNode){s=t.parentNode.__childNodes||t.parentNode.childNodes;const i=l["s-sn"];for(n=s.length-1;n>=0;n--)if(t=s[n],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==l["s-hn"]&&!S.experimentalSlotFixes)if(re(t,i)){let o=m.find(a=>a.$nodeToRelocate$===t);N=!0,t["s-sn"]=t["s-sn"]||i,o?(o.$nodeToRelocate$["s-sh"]=l["s-hn"],o.$slotRefNode$=l):(t["s-sh"]=l["s-hn"],m.push({$slotRefNode$:l,$nodeToRelocate$:t})),t["s-sr"]&&m.map(a=>{re(a.$nodeToRelocate$,t["s-sn"])&&(o=m.find(c=>c.$nodeToRelocate$===t),o&&!a.$slotRefNode$&&(a.$slotRefNode$=o.$slotRefNode$))})}else m.some(o=>o.$nodeToRelocate$===t)||m.push({$nodeToRelocate$:t})}l.nodeType===1&&xe(l)}},Le=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(Le)},E=(e,t,s)=>(typeof t["s-sn"]=="string"&&t["s-sr"]&&t["s-cr"]&&Oe(t["s-cr"],t,e,t.parentElement),e==null?void 0:e.insertBefore(t,s));function Oe(e,t,s,n){var r,l;let i;if(e&&typeof t["s-sn"]=="string"&&t["s-sr"]&&e.parentNode&&e.parentNode["s-sc"]&&(i=t["s-si"]||e.parentNode["s-sc"])){const o=t["s-sn"],a=t["s-hn"];if((r=s.classList)==null||r.add(i+"-s"),n&&((l=n.classList)!=null&&l.contains(i+"-s"))){let c=(n.__childNodes||n.childNodes)[0],f=!1;for(;c;){if(c["s-sn"]!==o&&c["s-hn"]===a&&c["s-sr"]){f=!0;break}c=c.nextSibling}f||n.classList.remove(i+"-s")}}}var dt=(e,t,s=!1)=>{var n,r,l,i,o;const a=e.$hostElement$,c=e.$cmpMeta$,f=e.$vnode$||M(null,null),$=tt(t)?t:Se(null,null,t);if(R=a.tagName,c.$attrsToReflect$&&($.$attrs$=$.$attrs$||{},c.$attrsToReflect$.map(([p,d])=>$.$attrs$[d]=a[p])),s&&$.$attrs$)for(const p of Object.keys($.$attrs$))a.hasAttribute(p)&&!["key","ref","style","class"].includes(p)&&($.$attrs$[p]=a[p]);$.$tag$=null,$.$flags$|=4,e.$vnode$=$,$.$elm$=f.$elm$=a.shadowRoot||a,C=a["s-sc"],Y=!!(c.$flags$&1)&&!(c.$flags$&128),z=a["s-cr"],N=!1,L(f,$,s);{if(g.$flags$|=1,V){xe($.$elm$);for(const p of m){const d=p.$nodeToRelocate$;if(!d["s-ol"]&&v.document){const h=v.document.createTextNode("");h["s-nr"]=d,E(d.parentNode,d["s-ol"]=h,d)}}for(const p of m){const d=p.$nodeToRelocate$,h=p.$slotRefNode$;if(h){const k=h.parentNode;let b=h.nextSibling;{let F=(n=d["s-ol"])==null?void 0:n.previousSibling;for(;F;){let y=(r=F["s-nr"])!=null?r:null;if(y&&y["s-sn"]===d["s-sn"]&&k===(y.__parentNode||y.parentNode)){for(y=y.nextSibling;y===d||y!=null&&y["s-sr"];)y=y==null?void 0:y.nextSibling;if(!y||!y["s-nr"]){b=y;break}}F=F.previousSibling}}const P=d.__parentNode||d.parentNode,D=d.__nextSibling||d.nextSibling;(!b&&k!==P||D!==b)&&d!==b&&(!d["s-hn"]&&d["s-ol"]&&(d["s-hn"]=d["s-ol"].parentNode.nodeName),E(k,d,b),d.nodeType===1&&d.tagName!=="SLOT-FB"&&(d.hidden=(l=d["s-ih"])!=null?l:!1)),d&&typeof h["s-rf"]=="function"&&h["s-rf"](h)}else d.nodeType===1&&(s&&(d["s-ih"]=(i=d.hidden)!=null?i:!1),d.hidden=!0)}}N&&ge($.$elm$),g.$flags$&=-2,m.length=0}if(S.experimentalScopedSlotChanges&&c.$flags$&2){const p=$.$elm$.__childNodes||$.$elm$.childNodes;for(const d of p)d["s-hn"]!==R&&!d["s-sh"]&&(s&&d["s-ih"]==null&&(d["s-ih"]=(o=d.hidden)!=null?o:!1),d.hidden=!0)}z=void 0},Ae=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const s=t["s-p"].push(new Promise(n=>e.$onRenderResolve$=()=>{t["s-p"].splice(s-1,1),n()}))}},W=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}return Ae(e,e.$ancestorComponent$),We(()=>ut(e,t))},ut=(e,t)=>{const s=e.$hostElement$,n=x("scheduleUpdate",e.$cmpMeta$.$tagName$),r=s;if(!r)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t?l=A(r,"componentWillLoad",void 0,s):l=A(r,"componentWillUpdate",void 0,s),l=$e(l,()=>A(r,"componentWillRender",void 0,s)),n(),$e(l,()=>ht(e,r,t))},$e=(e,t)=>pt(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),pt=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",ht=async(e,t,s)=>{var n;const r=e.$hostElement$,l=x("update",e.$cmpMeta$.$tagName$),i=r["s-rc"];s&&at(e);const o=x("render",e.$cmpMeta$.$tagName$);vt(e,t,r,s),i&&(i.map(a=>a()),r["s-rc"]=void 0),o(),l();{const a=(n=r["s-p"])!=null?n:[],c=()=>gt(e);a.length===0?c():(Promise.all(a).then(c),e.$flags$|=4,a.length=0)}},fe=null,vt=(e,t,s,n)=>{try{fe=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(S.hasRenderFn||S.reflect)&&(S.vdomRender||S.reflect)&&(S.hydrateServerSide||dt(e,t,n))}catch(a){H(a,e.$hostElement$)}return fe=null,null},gt=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,n=x("postUpdate",t),r=s,l=e.$ancestorComponent$;A(r,"componentDidRender",void 0,s),e.$flags$&64?(A(r,"componentDidUpdate",void 0,s),n()):(e.$flags$|=64,St(s),A(r,"componentDidLoad",void 0,s),n(),e.$onReadyResolve$(s),l||yt()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&K(()=>W(e,!1)),e.$flags$&=-517},jt=e=>{{const t=T(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&W(t,!1),s}},yt=e=>{K(()=>ke(v,"appload",{detail:{namespace:we}}))},A=(e,t,s,n)=>{if(e&&e[t])try{return e[t](s)}catch(r){H(r,n)}},St=e=>{var t;return e.classList.add((t=S.hydratedSelectorName)!=null?t:"hydrated")},_t=(e,t)=>T(e).$instanceValues$.get(t),de=(e,t,s,n)=>{const r=T(e),l=e,i=r.$instanceValues$.get(t),o=r.$flags$,a=l;s=_e(s,n.$members$[t][0]);const c=Number.isNaN(i)&&Number.isNaN(s);if(s!==i&&!c){r.$instanceValues$.set(t,s);{if(n.$watchers$&&o&128){const u=n.$watchers$[t];u&&u.map($=>{try{a[$](s,i,t)}catch(p){H(p,l)}})}if((o&18)===2){if(a.componentShouldUpdate&&a.componentShouldUpdate(s,i,t)===!1)return;W(r,!1)}}}},kt=(e,t,s)=>{var n,r;const l=e.prototype;if(t.$members$||t.$watchers$||e.watchers){e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);const i=Object.entries((n=t.$members$)!=null?n:{});i.map(([o,[a]])=>{if(a&31||a&32){const{get:c,set:f}=Object.getOwnPropertyDescriptor(l,o)||{};c&&(t.$members$[o][0]|=2048),f&&(t.$members$[o][0]|=4096),Object.defineProperty(l,o,{get(){return c?c.apply(this):_t(this,o)},configurable:!0,enumerable:!0}),Object.defineProperty(l,o,{set(u){const $=T(this);if(f){const p=a&32?this[o]:$.$hostElement$[o];typeof p>"u"&&$.$instanceValues$.get(o)?u=$.$instanceValues$.get(o):!$.$instanceValues$.get(o)&&p&&$.$instanceValues$.set(o,p),f.apply(this,[_e(u,a)]),u=a&32?this[o]:$.$hostElement$[o],de(this,o,u,t);return}{de(this,o,u,t);return}}})}});{const o=new Map;l.attributeChangedCallback=function(a,c,f){g.jmp(()=>{var u;const $=o.get(a);if(this.hasOwnProperty($)&&S.lazyLoad)f=this[$],delete this[$];else{if(l.hasOwnProperty($)&&typeof this[$]=="number"&&this[$]==f)return;if($==null){const d=T(this),h=d==null?void 0:d.$flags$;if(h&&!(h&8)&&h&128&&f!==c){const b=this,P=(u=t.$watchers$)==null?void 0:u[a];P==null||P.forEach(D=>{b[D]!=null&&b[D].call(b,f,c,a)})}return}}const p=Object.getOwnPropertyDescriptor(l,$);f=f===null&&typeof this[$]=="boolean"?!1:f,f!==this[$]&&(!p.get||p.set)&&(this[$]=f)})},e.observedAttributes=Array.from(new Set([...Object.keys((r=t.$watchers$)!=null?r:{}),...i.filter(([a,c])=>c[0]&15).map(([a,c])=>{var f;const u=c[1]||a;return o.set(u,a),c[0]&512&&((f=t.$attrsToReflect$)==null||f.push([a,u])),u})]))}}return e},bt=async(e,t,s,n)=>{let r;if(!(t.$flags$&32)){t.$flags$|=32,s.$lazyBundleId$;{r=e.constructor;const o=e.localName;customElements.whenDefined(o).then(()=>t.$flags$|=128)}if(r&&r.style){let o;typeof r.style=="string"?o=r.style:typeof r.style!="string"&&(t.$modeName$=rt(e),t.$modeName$&&(o=r.style[t.$modeName$]));const a=be(s,t.$modeName$);if(!B.has(a)){const c=x("registerStyles",s.$tagName$);ot(a,o,!!(s.$flags$&1)),c()}}}const l=t.$ancestorComponent$,i=()=>W(t,!0);l&&l["s-rc"]?l["s-rc"].push(i):i()},ue=(e,t)=>{},mt=e=>{if(!(g.$flags$&1)){const t=T(e),s=t.$cmpMeta$,n=x("connectedCallback",s.$tagName$);if(t.$flags$&1)Re(e,t,s.$listeners$),t!=null&&t.$lazyInstance$?ue(t.$lazyInstance$):t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ue(t.$lazyInstance$));else{t.$flags$|=1,s.$flags$&12&&Et(e);{let r=e;for(;r=r.parentNode||r.host;)if(r["s-p"]){Ae(t,t.$ancestorComponent$=r);break}}s.$members$&&Object.entries(s.$members$).map(([r,[l]])=>{if(l&31&&e.hasOwnProperty(r)){const i=e[r];delete e[r],e[r]=i}}),bt(e,t,s)}n()}},Et=e=>{if(!v.document)return;const t=e["s-cr"]=v.document.createComment("");t["s-cn"]=!0,E(e,t,e.firstChild)},Tt=async e=>{if(!(g.$flags$&1)){const t=T(e);t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0)}O.has(e)&&O.delete(e),e.shadowRoot&&O.has(e.shadowRoot)&&O.delete(e.shadowRoot)},Ht=(e,t)=>{customElements.define(t[1],xt(e,t))},xt=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};s.$members$=t[2],s.$listeners$=t[3],s.$watchers$=e.$watchers$,s.$attrsToReflect$=[];const n=e.prototype.connectedCallback,r=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__hasHostListenerAttached:!1,__registerHost(){Ue(this,s)},connectedCallback(){if(!this.__hasHostListenerAttached){const l=T(this);Re(this,l,s.$listeners$),this.__hasHostListenerAttached=!0}mt(this),n&&n.call(this)},disconnectedCallback(){Tt(this),r&&r.call(this)},__attachShadow(){if(!this.shadowRoot)this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)});else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}),e.is=s.$tagName$,kt(e,s)},Re=(e,t,s,n)=>{s&&v.document&&s.map(([r,l,i])=>{const o=Ot(v.document,e,r),a=Lt(t,i),c=At(r);g.ael(o,l,a,c),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>g.rel(o,l,a,c))})},Lt=(e,t)=>s=>{var n;try{S.lazyLoad||e.$hostElement$[t](s)}catch(r){H(r,e.$hostElement$)}},Ot=(e,t,s)=>s&4?e:s&8?v:s&16?e.body:t,At=e=>ze?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;export{Rt as H,et as a,wt as c,Ht as d,jt as f,Se as h};
